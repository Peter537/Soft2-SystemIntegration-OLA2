## Q7 - In Gregor Hohpe’s talk Enterprise Integration Patterns 2 he describes the idea of conversations in a messaging architecture (from 18 minutes). He explains how a ‘messaging’ and ‘conversation’ architecture are diNerent. What diNerences are there and what challenges does he describe for conversation based solutions (for example what is the diNerence between pub-sub and subscribe-notify)

Messaging er enkeltstående messages gennem pipes & filters i overvejende stateless komponenter med høj decoupling, scalability og enkel sammensætning. Conversations ser på participants over time og kræver delt state, herunder både conversation state og lokale projektioner, så man kan definere rules/ordering, lave reel error handling og sikre consistency. Det gør designet sværere, når du designer en protocol, skal undgå deadlocks, tænke completeness/termination, håndtere lifecycle ved crash/restart samt discovery/trust.

Forskellen mellem Publish-Subscribe og Subscribe-Notify er, at Publish-Subscribe handler om at route det enkelte event til alle subscribers, subscribe er en engangs composition, publish er runtime-mens Subscribe-Notify derimod handler om forholdet over tid: duration, lease/renewal og overlevelse ved genstarter.

## Q8 - Also in Gregor Hohpe’s video he explains the history and role of the idea of Patterns and Pattern Languages. How would you summarise what he explains – what do you see as the core requirements for patterns to be useful (see about 45 minutes in).

### Hvad han forklarer:

Hohpe viser, at messaging er den fundamentale at tænke i distributed systemer på. Explicit channels giver rumlig og tidslig afkobling, begrænser error propagation og optimerer throughput. Men fordi runtime behavior ikke ligner code structure, bliver design sværere og netop derfor bruger vi patterns som et fælles sprog.

### Messaging → Conversations

Real processes er ofte dialoger med anmodning, kvittering og forhandling. Ser man over tid, så vil state og fejlretning blive centrale. Derfor skelner han mellem publish–subscribe som route selection for en enkelt besked og subscribe–notify som et varigt forhold med leases. Samtaler kan kædes, encapsulated i lag eller køre parallelt.

### Core requirements for useful patterns:

Hohpe peger på, at et brugbart pattern kræver mere end “a solution to a common problem in a context”. Core requirements er:

- **Recurring**:

    Mønstret skal være baseret på gentagne, virkelige problemer og ikke bare være opfundet bag skrivebordet

- **Forces**: 

    Det skal forklare hvorfor og hvordan løsningen afvejer dem og ikke bare “gør sådan”.

- **Name**

    Et klart, mindeværdigt navn gør det muligt at tænke, tale og designe hurtigere.

- **Human-to-human communication**

    Patterns skal kunne bruges som et fælles sprog mellem mennesker. Patterns er små enheder til menneskelig kommunikation, ikke code generatorer.

- **Context**

    Hvad er situationen, begrænsningerne og konsekvenserne? 
    Hvad virker, hvornår og hvad koster det?

- **Belonging to a language**

    Mønstret skal indgå i et pattern language med klare relationer som alternativer og komplementer, med komposition og med en navigerbar struktur fra makro til mikro med tydelige fremadrettede henvisninger, så designere kan kombinere mønstre uden at overse afgørende beslutninger.

- **Intent matters**

    Selv hvis to løsninger ser ens ud, kan de være forskellige patterns, hvis intentionen er forskellig (f.eks. proxy for anonymitet vs. proxy for policy-enforcement).

- **Evidence & examples**

    Vis at mønstret lever i moderne platforme (Kafka, Pub/Sub, SQS, serverless) og kan implementeres uden unødig kompleksitet.

### Hvorfor har det betydning?

Når de krav er opfyldt, hjælper patterns os med at kombinere løsninger til robuste conversations og systemer uden at forveksle abstraction med farlig illusion.

## Q9 - In Simon Rohrer’s article on modern enterprise architecture (https://modernenterprisearchitecture.substack.com/p/modern-enterprise-architecture-a also on Moodle in the folder for slides for this week) he goes in to more detail about the ABCDE of modern EA he discusses the ‘strangler’ pattern for moving away from legacy systems – why is this seen as a complex problem and what does the strangler pattern do to help?

At bevæge sig væk fra legacy-systemer ses som et komplekst problem, fordi de ofte er monolitiske, rigide og tæt knyttede til forretningen, med begrænset tilpasningsevne til moderne krav som cloud-integration og hyppige, agile ændringer. Det fører til høje vedligeholdelsesomkostninger, integrationsudfordringer og en betydelig risiko for driftsforstyrrelser under udskiftning.

Strangler pattern hjælper ved at erstatte legacy-funktionalitet step by step, hvor man encapsulate det gamle system bag en facade/gateway, bygger nye komponenter omkring core og redirects gradvist trafikken, mens forældede dele fjernes. Herved undgår man en big-bang-omskrivning, reducerer risikoen, minimerer nedetid og muliggør løbende modernisering.


## Q10 - In Jesper Lowgren’s video Solution vs Enterprise Architecture Tutorial he describes three core diagrams that can be used to describe an architecture. What are they and what role do the play? Include examples.

De tre core diagrams der beskrives af Jesper Lowgren i Solution vs Enterprise Architecture Tutorial er:

1. **Solution Overview**:
   
   Rolen for dette diagram er at oversætte business requirements til et forretningsvenligt billede af løsningen. Den fanger core processes og hvordan mennesker, systemer og teknologi interagerer. Den skal være forståelig for virksomhedens interessenter.

   Hvad den typisk kan indeholde er f.eks.:
   - Key use cases / user journeys
   - A conceptual architecture of actors → processes → systems

2. Landscape Diagram:

    Rolen for dette diagram er at vise hvordan hvordan applikationer og data stores integrate og interagerer. Den bruges til impact analyse, dependency mapping, og planning.

    Hvad den typisk kan indeholde er f.eks.:
    - Applikationer, databaser, integrationer.
    - Interfaces (REST, events, files), data contracts, og directions of flow

3. Solution Design:
    
    Rolen for dette diagram er at agere som et blueprint for udvikling og implementering. Den beskriver konteksten på tværs af mennesker, processer, data, applikationer, teknologi og etc.

    Hvad den typisk kan indeholde er f.eks.:
    - Application architecture: apps, komponenter og services, deres grænseflader.
    - Data architecture: data stores/tables og relationships
    - Teknologi og infrastruktur: cloud/on-prem, networks, runtime platforms. Her kunne reference architectures også indgå for at align med standarder.